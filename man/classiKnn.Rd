% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/classiKnn.R
\name{classiKnn}
\alias{classiKnn}
\title{Create a knn estimator for functional data.}
\usage{
classiKnn(classes, fdata, grid = 1:ncol(fdata), knn = 1L,
  metric = "Euclidean", nderiv = 0L, derived = FALSE,
  deriv.method = "base.diff", own.metric = NULL, ...)
}
\arguments{
\item{classes}{[\code{factor(nrow(fdata))}]\cr
factor of length \code{nrow(fdata)} containing the classes of the observations.}

\item{fdata}{[\code{matrix}]\cr
matrix containing the functional observations as rows.}

\item{grid}{[\code{numeric(ncol(fdata))}]\cr
numeric vector containing the grid on which the functional observations were
evaluated.}

\item{knn}{[\code{integer(1)}]\cr
number of nearest neighbors to use in knn algorithm.}

\item{metric}{[\code{character(1)}]\cr
character string describing the distance function to be used.
 \describe{
  \item{\code{Euclidean}}{equals \code{Lp} with \code{p = 2}. This is the default.}
  \item{\code{Lp, Minkowski}}{the distance for an Lp-space.}
  \item{\code{Manhattan}}{equals \code{Lp} with \code{p = 1}.}
  \item{\code{...}}{all other available measures for \code{\link[proxy]{dist}}.}
  \item{\code{shortEuclidean}}{Euclidean distance on a limited part of the domain.
  Additional arguments \code{dmin} and \code{dmax} can be specified, giving
  the index of the first and the last point to use of an evenly spaced
  sequence from \code{grid[1]} to \code{grid[length(grid)]}.
  The default values are \code{dmin = 1L} and \code{dmax = length(grid)},
  which results in the Euclidean distance on the entire domain.}
  \item{\code{mean}}{the absolute similarity of the overall mean values of
  the observations.}
  \item{\code{relAreas}}{the difference of the relation of two areas on parts
  of the domain given by \code{dmin1} to \code{dmax1} and \code{dmin2} to
  \code{dmax2}. They are definded analougously to \code{dmin} and \code{dmax}
  and take the same default values.}
  \item{\code{jump}}{the similarity of jump heights at points \code{t1} and \code{t2}.
  The points \code{t1} and \code{t2} are the indices  in an evenly spaced sequence
  from \code{grid[1]} to \code{grid[length(grid)]} of which to compare the
  jump height. The default values are \code{t1 = 1} and \code{t2 = length(grid)}.}
  \item{\code{points}}{the differences at certain observation points, also
  called "points of impact". These are specified as a vector of indices
  of an evenly spaced sequence from \code{grid[1]} to \code{grid[length(grid)]}.
  The default value is \code{1L}.}
  \item{\code{custom.metric}}{your own semimetric will be used. Specify your
  own distance function in the argument \code{own.metric}}
 }}

\item{nderiv}{[\code{integer(1)}]\cr
The order of derivation on which the metric shall be computed.
The default is 0L.}

\item{derived}{[\code{logical(1)}]\cr
Is the data given in \code{fdata} already derived? Defaults to \code{FALSE},
which will lead to numerical derivation if \code{nderiv >= 1L} by applying
\code{\link[fda]{deriv.fd}} on a \code{\link[fda]{Data2fd}} representation of
\code{fdata}.}

\item{deriv.method}{[\code{character(1)}]\cr
character indicate which method should be used for derivation. Currently
implemented are \code{"base.diff"}, the default, and \code{"fda.deriv.fd"}.
\code{"base.diff"} uses the method \code{base::\link[base]{diff}} for equidistant measures
without missing values, which is faster than transforming the data into the
class \code{\link[fda]{fd}} and deriving this using \code{fda::\link[fda]{deriv.fd}}.
The second variant implies smoothing, which can be preferable for calculating
high order derivatives.}

\item{own.metric}{[\code{function(x, y, ...)}]\cr
returning a distance matrix with dimensions \code{nrow(x)} x \code{nrow(y)}.
See how to implement your distance function in \code{\link[proxy]{dist}}}

\item{...}{further arguments to and from other methods.}
}
\value{
\code{classiKnn} returns an object of class \code{"classiKnn"}. \cr
An object of class \code{"classiKnn"} is a  list containing the following
components:
 \describe{
  \item{\code{call}}{the original function call.}
  \item{\code{classes}}{a factor of length nrow(fdata) coding the response of
  the training data set.}
  \item{\code{fdata}}{the raw functional data as a matrix with the individual
  observations as rows.}
  \item{\code{grid}}{numeric vector containing the grid on which \code{fdata}
  is observed)}
  \item{\code{proc.fdata}}{the preprocessed data (missing values interpolated,
  derived and evenly spaced). This data is \code{this.fdataTransform(fdata)}.
  See \code{this.fdataTransform} for more details.}
  \item{\code{knn}}{integer coding the number of nearest neighbors used in the
  k nearest neighbor classification algorithm.}
  \item{\code{metric}}{character string coding the distance metric to be used
  in \code{\link{computeDistMat}}.}
  \item{\code{nderiv}}{integer giving the order of derivation that is applied
  to fdata before computing the distances between the observations.}
  \item{\code{this.fdataTransform}}{preprocessing function taking new data as
  a matrix. It is used to transform \code{fdata} into \code{proc.fdata} and
  is required to preprocess new data in order to predict it. This function
  ensures, that preprocessing (derivation, respacing and interpolation of
  missing values) is done in the exact same way for the original
  training data set and future (test) data sets.}
 }
}
\description{
Creates an efficient knn estimator for functional data. Currently
supported distance measures are all \code{metrics} implemented in \code{\link[proxy]{dist}}
and all semimetrics suggested in
Fuchs etal. 2015, Nearest neighbor ensembles for functional data with
interpretable feature selection,
(\url{http://www.sciencedirect.com/science/article/pii/S0169743915001100})
Additionally, all (semi-)metrics can be used on an arbitrary order of derivation.
}
\examples{
# Classification of the Phoneme data
data(Phoneme)
classes = Phoneme[,"target"]

set.seed(123)
# Use 80\% of data as training set and 20\% as test set
train_inds = sample(1:nrow(Phoneme), size = 0.8 * nrow(Phoneme), replace = FALSE)
test_inds = (1:nrow(Phoneme))[!(1:nrow(Phoneme)) \%in\% train_inds]

# create functional data as matrix with observations as rows
fdata = Phoneme[,!colnames(Phoneme) == "target"]

# create 3 nearest neighbor classifier with Euclidean distance (default) of the
# first order derivative of the data
mod = classiKnn(classes = classes[train_inds], fdata = fdata[train_inds,],
                 nderiv = 1L, knn = 3L)

# predict the model for the test set
pred = predict(mod, newdata =  fdata[test_inds,], predict.type = "prob")
}
